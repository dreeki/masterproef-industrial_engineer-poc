{"version":3,"file":"HttpServiceSparqlEndpoint.js","sourceRoot":"","sources":["HttpServiceSparqlEndpoint.ts"],"names":[],"mappings":"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","sourcesContent":["import {LoggerPretty} from \"@comunica/logger-pretty\";\nimport * as fs from \"fs\";\nimport * as http from \"http\";\nimport EventEmitter = NodeJS.EventEmitter;\nimport minimist = require(\"minimist\");\nimport * as querystring from \"querystring\";\nimport {Writable} from \"stream\";\nimport * as url from \"url\";\nimport {newEngineDynamic} from \"../index\";\nimport {ActorInitSparql} from \"./ActorInitSparql\";\nimport {IQueryOptions} from \"./QueryDynamic\";\n\n/**\n * An HTTP service that exposes a Comunica engine as a SPARQL endpoint.\n */\nexport class HttpServiceSparqlEndpoint {\n  public static readonly MIME_PLAIN = 'text/plain';\n  public static readonly MIME_JSON  = 'application/json';\n  // tslint:disable:max-line-length\n  public static readonly HELP_MESSAGE = `comunica-sparql-http exposes a Comunica engine as SPARQL endpoint\n\ncontext should be a JSON object or the path to such a JSON file.\n\nUsage:\n  comunica-sparql-http context.json [-p port] [-t timeout] [-l log-level] [-i] [--help]\n  comunica-sparql-http \"{ \\\\\"sources\\\\\": [{ \\\\\"type\\\\\": \\\\\"hypermedia\\\\\", \\\\\"value\\\\\" : \\\\\"http://fragments.dbpedia.org/2015/en\\\\\" }]}\" [-p port] [-t timeout] [-l log-level] [-i] [--help]\n\nOptions:\n  -p            The HTTP port to run on (default: 3000)\n  -t            The query execution timeout in seconds (default: 60)\n  -l            Sets the log level (e.g., debug, info, warn, ... defaults to warn)\n  -i            A flag that enables cache invalidation before each query execution.\n  --help        print this help message\n`;\n  // tslint:enable:max-line-length\n  public readonly engine: Promise<ActorInitSparql>;\n\n  public readonly context: any;\n  public readonly timeout: number;\n  public readonly port: number;\n\n  public readonly invalidateCacheBeforeQuery: boolean;\n\n  constructor(args?: IHttpServiceSparqlEndpointArgs) {\n    args = args || {};\n    this.context = args.context || {};\n    this.timeout = args.timeout || 60000;\n    this.port = args.port || 3000;\n    this.invalidateCacheBeforeQuery = args.invalidateCacheBeforeQuery;\n\n    this.engine = newEngineDynamic(args);\n  }\n\n  /**\n   * Starts the server\n   * @param {string[]} argv The commandline arguments that the script was called with\n   * @param {module:stream.internal.Writable} stdout The output stream to log to.\n   * @param {module:stream.internal.Writable} stderr The error stream to log errors to.\n   * @param {string} moduleRootPath The path to the invoking module.\n   * @param {NodeJS.ProcessEnv} env The process env to get constants from.\n   * @param {string} defaultConfigPath The path to get the config from if none is defined in the environment.\n   * @param {(code: number) => void} exit The callback to invoke to stop the script.\n   * @return {Promise<void>} A promise that resolves when the server has been started.\n   */\n  public static runArgsInProcess(argv: string[], stdout: Writable, stderr: Writable,\n                                 moduleRootPath: string, env: NodeJS.ProcessEnv,\n                                 defaultConfigPath: string, exit: (code: number) => void): Promise<void> {\n    const args = minimist(argv);\n    if (args._.length !== 1 || args.h || args.help) {\n      stderr.write(HttpServiceSparqlEndpoint.HELP_MESSAGE);\n      exit(1);\n    }\n\n    const options = HttpServiceSparqlEndpoint\n        .generateConstructorArguments(args, moduleRootPath, env, defaultConfigPath);\n\n    return new Promise<void>((resolve) => {\n      new HttpServiceSparqlEndpoint(options).run(stdout, stderr)\n          .then(resolve)\n          .catch((reason) => {\n            stderr.write(reason);\n            exit(1);\n            resolve();\n          });\n    });\n  }\n\n  /**\n   * Takes parsed commandline arguments and turns them into an object used in the HttpServiceSparqlEndpoint constructor\n   * @param {args: minimist.ParsedArgs} args The commandline arguments that the script was called with\n   * @param {string} moduleRootPath The path to the invoking module.\n   * @param {NodeJS.ProcessEnv} env The process env to get constants from.\n   * @param {string} defaultConfigPath The path to get the config from if none is defined in the environment.\n   */\n  public static generateConstructorArguments(args: minimist.ParsedArgs, moduleRootPath: string,\n                                             env: NodeJS.ProcessEnv, defaultConfigPath: string)\n      : IHttpServiceSparqlEndpointArgs {\n    // allow both files as direct JSON objects for context\n    const context = JSON.parse(fs.existsSync(args._[0]) ? fs.readFileSync(args._[0], 'utf8') : args._[0]);\n    const invalidateCacheBeforeQuery: boolean = args.i;\n    const port = parseInt(args.p, 10) || 3000;\n    const timeout = (parseInt(args.t, 10) || 60) * 1000;\n\n    // Set the logger\n    if (!context.log) {\n      context.log = new LoggerPretty({ level: args.l || 'warn' });\n    }\n\n    const configResourceUrl = env.COMUNICA_CONFIG ? env.COMUNICA_CONFIG : defaultConfigPath;\n\n    return {\n      configResourceUrl,\n      context,\n      invalidateCacheBeforeQuery,\n      mainModulePath: moduleRootPath,\n      port,\n      timeout,\n    };\n  }\n\n  /**\n   * Start the HTTP service.\n   * @param {module:stream.internal.Writable} stdout The output stream to log to.\n   * @param {module:stream.internal.Writable} stderr The error stream to log errors to.\n   */\n  public async run(stdout: Writable, stderr: Writable) {\n    const engine: ActorInitSparql = await this.engine;\n\n    // Determine the allowed media types for requests\n    const mediaTypes: {[id: string]: number} = await engine.getResultMediaTypes(null);\n    const variants: { type: string, quality: number }[] = [];\n    for (const type of Object.keys(mediaTypes)) {\n      variants.push({ type, quality: mediaTypes[type] });\n    }\n\n    // Start the server\n    const server = http.createServer(this.handleRequest.bind(this, engine, variants, stdout, stderr));\n    server.listen(this.port);\n    server.setTimeout(2 * this.timeout); // unreliable mechanism, set too high on purpose\n    stderr.write('Server running on http://localhost:' + this.port + '/\\n');\n  }\n\n  /**\n   * Handles an HTTP request.\n   * @param {ActorInitSparql} engine A SPARQL engine.\n   * @param {{type: string; quality: number}[]} variants Allowed variants.\n   * @param {module:stream.internal.Writable} stdout Output stream.\n   * @param {module:stream.internal.Writable} stderr Error output stream.\n   * @param {module:http.IncomingMessage} request Request object.\n   * @param {module:http.ServerResponse} response Response object.\n   */\n  public async handleRequest(engine: ActorInitSparql, variants: { type: string, quality: number }[],\n                             stdout: Writable, stderr: Writable,\n                             request: http.IncomingMessage, response: http.ServerResponse) {\n    const mediaType: string = request.headers.accept && request.headers.accept !== '*/*'\n      ? require('negotiate').choose(variants, request)[0].type : null;\n\n    // Verify the path\n    const requestUrl = url.parse(request.url, true);\n    if (requestUrl.pathname !== '/sparql') {\n      stdout.write('[404] Resource not found\\n');\n      response.writeHead(404,\n          { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON, 'Access-Control-Allow-Origin': '*' });\n      response.end(JSON.stringify({ message: 'Resource not found' }));\n      return;\n    }\n\n    if (this.invalidateCacheBeforeQuery) {\n      // Invalidate cache\n      await engine.invalidateHttpCache();\n    }\n\n    // Parse the query, depending on the HTTP method\n    let sparql;\n    switch (request.method) {\n    case 'POST':\n      sparql = await this.parseBody(request);\n      this.writeQueryResult(engine, stdout, stderr, request, response, sparql, mediaType, false);\n      break;\n    case 'HEAD':\n    case 'GET':\n      sparql = <string> (<querystring.ParsedUrlQuery> requestUrl.query).query || '';\n      this.writeQueryResult(engine, stdout, stderr, request, response, sparql, mediaType, request.method === 'HEAD');\n      break;\n    default:\n      stdout.write('[405] ' + request.method + ' to ' + requestUrl + '\\n');\n      response.writeHead(405,\n          { 'content-type': HttpServiceSparqlEndpoint.MIME_JSON, 'Access-Control-Allow-Origin': '*' });\n      response.end(JSON.stringify({ message: 'Incorrect HTTP method' }));\n    }\n  }\n\n  /**\n   * Writes the result of the given SPARQL query.\n   * @param {ActorInitSparql} engine A SPARQL engine.\n   * @param {module:stream.internal.Writable} stdout Output stream.\n   * @param {module:stream.internal.Writable} stderr Error output stream.\n   * @param {module:http.IncomingMessage} request Request object.\n   * @param {module:http.ServerResponse} response Response object.\n   * @param {string} sparql The SPARQL query string.\n   * @param {string} mediaType The requested response media type.\n   * @param {boolean} headOnly If only the header should be written.\n   */\n  public writeQueryResult(engine: ActorInitSparql, stdout: Writable, stderr: Writable,\n                          request: http.IncomingMessage, response: http.ServerResponse,\n                          sparql: string, mediaType: string, headOnly: boolean) {\n    let eventEmitter: EventEmitter;\n    engine.query(sparql, this.context)\n      .then(async (result) => {\n        stdout.write('[200] ' + request.method + ' to ' + request.url + '\\n');\n        stdout.write('      Requested media type: ' + mediaType + '\\n');\n        stdout.write('      Received query: ' + sparql + '\\n');\n        response.writeHead(200, { 'content-type': mediaType, 'Access-Control-Allow-Origin': '*'  });\n\n        if (headOnly) {\n          response.end();\n          return;\n        }\n\n        try {\n          const data: NodeJS.ReadableStream = (await engine.resultToString(result, mediaType)).data;\n          data.on('error', (e: Error) => {\n            stdout.write('[500] Server error in results: ' + e + ' \\n');\n            response.end('An internal server error occurred.\\n');\n          });\n          data.pipe(response);\n          eventEmitter = data;\n        } catch (error) {\n          stdout.write('[400] Bad request, invalid media type\\n');\n          response.writeHead(400,\n              { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });\n          response.end('The response for the given query could not be serialized for the requested media type\\n');\n        }\n      }).catch((error) => {\n        stdout.write('[400] Bad request\\n');\n        response.writeHead(400,\n            { 'content-type': HttpServiceSparqlEndpoint.MIME_PLAIN, 'Access-Control-Allow-Origin': '*' });\n        response.end(error.toString());\n      });\n\n    this.stopResponse(response, eventEmitter);\n  }\n\n  /**\n   * Stop after timeout or if the connection is terminated\n   * @param {module:http.ServerResponse} response Response object.\n   * @param {NodeJS.ReadableStream} eventEmitter Query result stream.\n   */\n  public stopResponse(response: http.ServerResponse, eventEmitter: EventEmitter) {\n    // Note: socket or response timeouts seemed unreliable, hence the explicit timeout\n    const killTimeout = setTimeout(killClient, this.timeout);\n    response.on('close', killClient);\n    function killClient() {\n      if (eventEmitter) {\n        // remove all listeners so we are sure no more write calls are made\n        eventEmitter.removeAllListeners();\n        eventEmitter.emit('end');\n      }\n      try { response.end(); } catch (e) { /* ignore error */ }\n      clearTimeout(killTimeout);\n    }\n  }\n\n  /**\n   * Parses the body of a SPARQL POST request\n   * @param {module:http.IncomingMessage} request Request object.\n   * @return {Promise<string>} A promise resolving to a query string.\n   */\n  public parseBody(request: http.IncomingMessage): Promise<string> {\n    return new Promise((resolve, reject) => {\n      let body = '';\n      request.setEncoding('utf8');\n      request.on('error', reject);\n      request.on('data', (chunk) => { body += chunk; });\n      request.on('end', () => {\n        const contentType: string = request.headers['content-type'];\n        if (contentType.indexOf('application/sparql-query') >= 0) {\n          return resolve(body);\n        } else if (contentType.indexOf('application/x-www-form-urlencoded') >= 0) {\n          return resolve(<string> querystring.parse(body).query || '');\n        } else {\n          return resolve(body);\n        }\n      });\n    });\n  }\n}\n\nexport interface IHttpServiceSparqlEndpointArgs extends IQueryOptions {\n  context?: any;\n  timeout?: number;\n  port?: number;\n  invalidateCacheBeforeQuery?: boolean;\n}\n"]}