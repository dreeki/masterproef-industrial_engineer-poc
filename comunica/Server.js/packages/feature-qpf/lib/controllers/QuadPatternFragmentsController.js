/*! @license MIT Â©2015-2018 Ruben Verborgh and Ruben Taelman, Ghent University - imec */
/** A QuadPatternFragmentsController responds to requests for TPFs and QPFs */

let Controller = require('@ldf/core').controllers.Controller,
    url = require('url'),
    _ = require('lodash');

// Creates a new QuadPatternFragmentsController
class QuadPatternFragmentsController extends Controller {
  constructor(options) {
    options = options || {};
    super(options);
    this._routers = options.routers || [];
    this._extensions = options.extensions || [];

    this.viewName = 'QuadPatternFragments';
  }

  // The required features the given datasource must have
  supportsDatasource(datasource) {
    return datasource.supportedFeatures.triplePattern ||
          datasource.supportedFeatures.quadPattern;
  }

  // Try to serve the requested fragment
  _handleRequest(request, response, next) {
    // Create the query from the request by calling the fragment routers
    let requestParams = { url: request.parsedUrl, headers: request.headers },
        query = this._routers.reduce((query, router) => {
          try { router.extractQueryParams(requestParams, query); }
          catch (e) { /* ignore routing errors */ }
          return query;
        }, { features: [] });

    // Execute the query on the data source
    let datasource = query.features.datasource && this._datasources[query.datasource];
    delete query.features.datasource;
    if (!datasource || !datasource.supportsQuery(query) ||
      !this.supportsDatasource(datasource))
      return next();

    // Generate the query result
    let view = this._negotiateView(this.viewName, request, response),
        settings = this._createFragmentMetadata(request, query, datasource);
    settings.results = datasource.select(query,
      (error) => { error && next(error); });

    // Execute the extensions and render the query result
    let extensions = this._extensions, extensionId = 0;
    (function nextExtension(error) {
      // Log a possible error with the previous extension
      if (error)
        process.stderr.write(error.stack + '\n');
      // Execute the next extension
      if (extensionId < extensions.length)
        extensions[extensionId++].handleRequest(request, response, nextExtension, settings);
      // Render the query result
      else
        view.render(settings, request, response);
    })();
  }

  // Create the template URL for requesting quad patterns
  _createTemplateUrl(datasourceUrl, supportsQuads) {
    return datasourceUrl + (!supportsQuads ? '{?subject,predicate,object}' :
      '{?subject,predicate,object,graph}');
  }

  // Create parameterized pattern string for quad patterns
  _createPatternString(query, supportsQuads) {
    let subject = query.subject, predicate = query.predicate,
        object = query.object, graph = '';
    // Serialize subject and predicate IRIs or variables
    subject   = subject   ? '<' + query.subject.value   + '> ' : '?s ';
    predicate = predicate ? '<' + query.predicate.value + '> ' : '?p ';
    // Serialize object IRI, literal, or variable
    if (query.object && query.object.termType === 'NamedNode')
      object = '<' + query.object.value + '> ';
    else
      object = query.object ? query.object.value : '?o';
    // Serialize graph IRI default graph, or variable
    if (supportsQuads) {
      graph = query.graph;
      if (graph && graph.termType === 'DefaultGraph') graph = ' @default';
      else if (graph)   graph = ' <' + graph.value + '>';
      else              graph = ' ?g';
    }
    // Join them in a pattern
    return '{ ' + subject + predicate + object + graph + '. }';
  }

  // Creates metadata about the requested fragment
  _createFragmentMetadata(request, query, datasourceSettings) {
    // TODO: these URLs should be generated by the routers
    let requestUrl = request.parsedUrl,
        // maintain the originally requested query string to avoid encoding differences
        origQuery = request.url.replace(/[^?]+/, ''),
        pageUrl = url.format(requestUrl).replace(/\?.*/, origQuery),
        paramsNoPage = _.omit(requestUrl.query, 'page'),
        currentPage = parseInt(requestUrl.query.page, 10) || 1,
        datasourceUrl = url.format(_.omit(requestUrl, 'query')),
        fragmentUrl = url.format({ ...requestUrl, query: paramsNoPage }),
        fragmentPageUrlBase = fragmentUrl + (/\?/.test(fragmentUrl) ? '&' : '?') + 'page=',
        indexUrl = url.format(_.omit(requestUrl, 'search', 'query', 'pathname')) + '/';

    // Generate a textual representation of the pattern
    let supportsQuads = datasourceSettings.supportedFeatures.quadPattern || false;
    query.patternString = this._createPatternString(query, supportsQuads);

    return {
      datasource: _.assign(datasourceSettings, {
        index: indexUrl + '#dataset',
        url: datasourceUrl + '#dataset',
        templateUrl: this._createTemplateUrl(datasourceUrl, supportsQuads),
        supportsQuads: supportsQuads,
      }),
      fragment: {
        url: fragmentUrl,
        pageUrl: pageUrl,
        firstPageUrl: fragmentPageUrlBase + '1',
        nextPageUrl: fragmentPageUrlBase + (currentPage + 1),
        previousPageUrl: currentPage > 1 ? fragmentPageUrlBase + (currentPage - 1) : null,
      },
      query: query,
      prefixes: this._prefixes,
      datasources: this._datasources,
    };
  }

  // Close all data sources
  close() {
    for (let datasourceName in this._datasources) {
      try { this._datasources[datasourceName].close(); }
      catch (error) { /* ignore closing errors */ }
    }
  }
}

module.exports = QuadPatternFragmentsController;
